# 控制脚本执行

```php
void exit ( [mixed status])
mixed eval ( [string code_string])
void die ( [mixed status])
```

两个简单的函数使你的脚本如虎添翼：`exit()`和`eval()`——二者都很简单。`exit()`只有一个可选参数，会立即停止执行脚本。如果你给它传递一个参数，这个参数将被作为退出码；如果这个参数是个字符串，这个字符串将被打印出来。函数`die()`是`exit()`的别名，它们两个工作方式完全一样。`eval()`将一个字符串作为参数，如果这个字符串是PHP代码的话，它将执行这个代码。下面是`exit()`和`eval()`的例子：

```php
<?php
    $str = "exit()";
    eval($str);
?>
```

> 对于老学究而言，`exit()`不是函数，而是一种语言结构。

上面的脚本将`"exit()"`赋值给`$str`，然后将`$str`传递给`eval()`。如上所述，如果传入的字符串是PHP代码的话，`eval()`会将去执行，因此，通过`eval()`执行`exit()`导致代码中止。

`exit()`是个用的很多的函数，只要你想中止代码执行，就可以使用。例如：

```php
if ($blah != $blahblah) {
    print "Access denied.";
    exit;
}
```

`eval()`看起来对你没有什么用，但实际用处还是很大的：允许你将任意字符串传入并作为PHP代码执行，逊于你讲PHP代码存在数据库当中，或凭空执行代码。总之，给了你极大的便利。

`exit()`函数最多带一个参数，可以是程序返回码，也可以是数字。许多程序返回数字，其他程序可以根据返回的数字来判断执行情况。在这种情况下，0通常意味“程序正常”，其他返回码则往往说明“程序出错”。在`exit()`中使用字符串的话，PHP会先输出这个字符串，之后再中止程序——通常使用`exit()`的别名`die()`：

```php
do_some_func() OR die("do_some_func() returned false!");
```

在这种情况下，将会调用`do_some_func()`，如果返回`false`的话，将会调用`die()`中止程序。在你被代码绕晕之前，这是确保这个函数正确成功执行的最快最好的方法。因为`OR`操作符的短路功能，只有第一个函数返回`false`的情况下，PHP才会去执行后面的部分。

这是`OR`操作符最常用的情景。想一下前面介绍的，`||`操作符从优先级上来说比`OR`要高，同时，`||`的优先级比`=`也要高。

现在，来猜猜下面的代码的执行结果是什么：

```php
$fp = fopen("somefile", "r") || die("Could not open file!");
```

表面上看起来和上面`die()`的例子一样：PHP将尝试载入文件somefile并将文件指针保存到`$fp`当中，如果失败的话，程序退出并输出Could not open file!。实际并**不是**这样的。相反，由于`||`的优先级比`=`要高，将会首先计算，所以PHP将首先尝试载入文件。如果成功了，`fopen()`将会返回于true的资源。当然，调用`die()`肯定是会成功的，因此也会返回为true的资源。由于PHP的`||`有短路的特性，当`fopen()`调用成功的时候，`die()`便不会被执行，而`||`会因为其左侧(`fopen()`函数)返回true而返回1。

实际上，PHP是这样读入这行代码的：

```php
$fp = (fopen("somefile", "r") || die("Could not open file!"));
```

最终，`$fp`将被赋值为1。很明显，这不是我们想要的。这就是为什么用`OR`操作符的原因了。由于`OR`的优先级比`=`要低，PHP会这样读入代码：

```php
($fp = fopen("somefile", "r")) or die("Could not open file!");
```

也就是说，`fopen()`被调用后，返回值被赋值给`$fp`，之后再通过比较操作符。这就是为什么需要`||`也需要`OR`的原因了。使用的时候你需要注意正确选择。

> 作者说明：我建议你时刻谨记PHP创造者Rasmus Lerdorf的话：“如果`eval()`是答案的话，几乎可以肯定你问了一个愚蠢的问题。”这并不是说`eval()`不好，而是说你应该在使用之前再三考虑。
