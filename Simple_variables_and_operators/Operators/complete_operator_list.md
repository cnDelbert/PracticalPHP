# 完整的操作符列表

作为一本要成为PHP手册的书，不把PHP所有操作符都列出来是不对的。

## 算术操作符

|`$a + $b`| 加法 | `$a`和`$b`的和 |
|:-:|:-:|:-:|
|`$a - $b`| 减法 | `$a`和`$b`的差 |
|`$a * $b`| 乘法 | `$a`和`$b`的积 |
|`$a / $b`| 除法 | `$a`除以`$b`的商 |
|`$a % $b`| 取模 | `$a`除以`$b`的余数 |

如果你在学校就没有学过取模，下面是一个简单说明。要计算`$a % $b`，首先计算`$a / $b`，得到一个余数。例如，`$a`等于10，`$b`等于3，10除以3得3余1，因此`10 % 3`就是1。

## 赋值操作符

|`$a = $b`| 相等 | 将`$a`赋值给`$b` |
|:-:|:-:|:-:|
|`$a =& $b`| 引用 | 将`$a`作为`$b`的引用 |

二者的区别之后再解释，现在你只要知道一个正常的变量有自己的值，一个引用变量拥有别的变量的值就可以了。

## 按位操作符

|`$a & $b`| 按位与 and | `$a`与`$b`同为真的置位 |
|:-:|:-:|:-:|
|`$a | $b`| 按位或 or | `$a`与`$b`有一个为真的置位 |
|`$a ^ $b`| 按位异或 xor | `$a`与`$b`不同的置位 |
|`~$a`| 按位非 not | 将`$a`按位取反 |
|`$a << $b`| 左移 | 将`$a`左移`$b`位，每移动一位相当于乘以2 |
|`$a >> $b`| 右移 | 将`$a`右移`$b`位 |

按位操作使用频率不高，通常在PHP高级程序员当中使用。他们按二进制位操作数字，而普通程序员并不需要。

举例来说，数字8用八位二进制表示是00001000，左移(<<)一位变成00010000，也就是16。八左移四位成为10000000，相当于128，也就是8乘以了2的4次方。

按位与(&)操作会按位比较操作数一和操作数二，并最后返回结果。例如`52 & 28`，换算成八位二进制是 00110100(52)和00011100(28)。PHP首先创造一个 00000000，然后依次比较两数的每个位，当两个位都是1的时候，将对应位置置一。就像下面这样：

```text
001 1 0 1 00 (52)
000 1 1 1 00 (28)
000 1 0 1 00 (20)
```

因此，`52 & 28`的结果就是20。正如你所认为的那样，按位进行的运算使用的情况不多，但是你最好知道一点，万一哪天你在别人的代码中见到了你不会手足无措。

或许用的最多的按位操作符是`|`了，操作数一和操作数二对应位置上有一个为1时就将对应位置置一。例如：

```text
0011 0 1 0 0 (52)
1101 0 0 0 1 (209)
1111 0 1 0 1 (245)
```

按位或操作允许你将好几种选项拼合在一起，所以很有用。例如，`flock()`函数，它将一个常量作为第二个参数传入，来描述你想如何锁定文件。例如，`LOCK_EX`是独占式锁定文件，`LOCK_SH`是在共享模式下锁定，`LOCK_NB`是非阻塞模式，使PHP在无锁时不必等待。

如果想要独占式锁定，又不想阻塞，应该怎么办呢？这种情况下就可以使用按位或操作了：将`LOCK_EX | LOCK_NB`作为参数传入，PHP就知道你想要什么了。

## 比较操作符

所有的比较操作符要么返回真，要么返回假，因此特别适合进行条件判断。

|`$a == $b`|相等|`$a`与`$b`相等时返回真|
|:-:|:-:|:-:|
|`$a === $b`|同一|`$a`与`$b`相等且同类型时返回真|
|`$a != $b`|不等|`$a`与`$b`不等时返回真|
|`$a <> $b`|不等|`$a`与`$b`不等时返回真|
|`$a !== $b`|不同一|`$a`与`$b`不相等或不同类型时返回真|
|`$a < $b`|小于|`$a`小于`$b`时返回真|
|`$a > $b`|大于|`$a`大于`$b`不等时返回真|
|`$a <= $b`|小于等于|`$a`小于等于`$b`时返回真|
|`$a >= $b`|大于等于|`$a`大于等于`$b`时返回真|

总体来说，PHP程序员相比于`<>`更喜欢`!=`，虽然二者作用完全一样。这种偏爱是由于大部分PHP语法同C相同，而C语言之使用`!=`。

同一`===`使用频率远远不如相等`==`，但是在某些场合下特别有用。我们用下面的代码来说明两个变量只有在值相同且类型相同的情况下才是同一这个问题：

```php
<?php
    print 12 == 12;
    print 12 === 12;
    print "12" == 12;
    print "12" === 12;
?>
```

如果你在命令行当中运行上面的脚本，PHP在前三行输出1，第四行什么都没输出。正如之前说过的，PHP输出1表示真，什么都不输出表示假：`"12"`和`12`虽然值相同，但是类型不同，前者是一个字符串，后者是一个数字。

## 自增自减操作符

|`++$a`|前置自增|`$a`自增1，之后返回`$a`|
|:-:|:-:|:-:|
|`$a++`|后置自增|返回`$a`，之后`$a`自增1|
|`--$a`|前置自减|`$a`自减1，之后返回`$a`|
|`$a--`|后置自减|返回`$a`，之后`$a`自减1|

正如你所看到的，自增自建操作符可以放在变量前面，也可以放在变量后面。符号放置的位置不同，效果也不一样。来看一下下面的例子：

```php
<?php
    $foo = 5;
    $bar = $foo++;
    print "Foo is $foo\n";
    print "Bar is $bar\n";
?>
```

上面的代码输出：

```text
Foo is 6
Bar is 5
```

由于`++`符号放在变量好眠，是后置自增运算符，先返回原变量的值，之后再自增一。在代码的第二行，`$foo`返回的值保存在`$bar`当中，之后`$foo`再自增一。如果我们用`++$foo`，则会将变量先自增一再返回，也就是说`$foo`和`$bar`的值都是6。

## 逻辑运算符

|`$a and $b`|与|如果`$a`和`$b`都为真则为真|
|:-:|:-:|:-:|
|`$a && $b`|与|如果`$a`和`$b`都为真则为真|
|`$a or $b`|或|如果`$a`或`$b`一个为真则为真|
|`$a || $b`|或|如果`$a`或`$b`一个为真则为真|
|`$a xor $b`|异或|`$a`或`$b`一个为真则为真，两个都为真时为假|
|`!$a`|菲|`$a`为假时为真|

上标中逻辑与和逻辑或都有两种符号表示，在一些复杂的表达式中更容易处理。通常来讲，用`&&`和`||`比较多，但是这两个符号在`die()`函数中会引起异常，之后在详细说明。

注意一下，PHP中的条件运算符是采用短路算法的，也就是说“你的带入如果想要A或B为真，PHP检查到A为真后就不会检查B的值了，因为已经能够满足条件了”。当然，如果第一个条件判断是吧，在或运算的时候，PHP还是会检查第二个条件的。
